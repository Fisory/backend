import jwt from 'jsonwebtoken';import redisClient from '@/config/redis';import { jwtConfig, JwtPayload } from '@/config/jwt';import {   generateVerifyCode,   sendLoginVerifyCode,   validatePhoneNumber } from '@/services/sms.service';import {  findUserByPhone,  createUser,} from '@/repositories/user.repository';import { User } from '@prisma/client';const REDIS_KEY_PREFIX = {  SMS_CODE: 'sms:login',             SMS_RATE_LIMIT: 'sms:rate',      };const SMS_CONFIG = {  CODE_LENGTH: 6,                    CODE_EXPIRE: 300,                  RATE_LIMIT_EXPIRE: 60,           };export const sendVerifyCode = async (phone: string): Promise<void> => {  if (!validatePhoneNumber(phone)) {    throw new Error('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®');  }  const rateLimitKey = `${REDIS_KEY_PREFIX.SMS_RATE_LIMIT}:${phone}`;  const rateLimitExists = await redisClient.exists(rateLimitKey);  if (rateLimitExists) {    const ttl = await redisClient.ttl(rateLimitKey);    throw new Error(`å‘é€è¿‡äºé¢‘ç¹ï¼Œè¯· ${ttl} ç§’åå†è¯•`);  }  const code = generateVerifyCode(SMS_CONFIG.CODE_LENGTH);  console.log(`ğŸ“± ç”ŸæˆéªŒè¯ç : ${phone} -> ${code}`);  const codeKey = `${REDIS_KEY_PREFIX.SMS_CODE}:${phone}`;  await redisClient.setex(codeKey, SMS_CONFIG.CODE_EXPIRE, code);  console.log(`âœ… éªŒè¯ç å·²å­˜å…¥ Redis: ${codeKey}, TTL: ${SMS_CONFIG.CODE_EXPIRE}s`);  const sendSuccess = await sendLoginVerifyCode(phone, code);  if (!sendSuccess) {    await redisClient.del(codeKey);    throw new Error('çŸ­ä¿¡å‘é€å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');  }  await redisClient.setex(rateLimitKey, SMS_CONFIG.RATE_LIMIT_EXPIRE, '1');  console.log(`âœ… çŸ­ä¿¡å‘é€æˆåŠŸ: ${phone}`);};export const loginWithVerifyCode = async (  phone: string,  code: string): Promise<{ user: User; token: string }> => {  if (!validatePhoneNumber(phone)) {    throw new Error('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®');  }  const codeKey = `${REDIS_KEY_PREFIX.SMS_CODE}:${phone}`;  const storedCode = await redisClient.get(codeKey);  if (!storedCode) {    throw new Error('éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–');  }  if (storedCode !== code) {    throw new Error('éªŒè¯ç é”™è¯¯');  }  console.log(`âœ… éªŒè¯ç éªŒè¯é€šè¿‡: ${phone}`);  let user = await findUserByPhone(phone);  if (!user) {    console.log(`ğŸ“ ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè‡ªåŠ¨æ³¨å†Œ: ${phone}`);    const nickname = `ç”¨æˆ·${phone.slice(-4)}`;    user = await createUser({      phone,      nickname,    });    console.log(`âœ… ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: ${user.id}`);  }  const token = generateToken(user.id);  console.log(`âœ… JWT Token ç”ŸæˆæˆåŠŸ: userId=${user.id}`);  await redisClient.del(codeKey);  console.log(`âœ… éªŒè¯ç å·²åˆ é™¤: ${codeKey}`);  return {    user,    token,  };};export const generateToken = (userId: bigint | string | number): string => {  const payload: JwtPayload = {    userId: userId.toString(),     iss: jwtConfig.issuer,    aud: jwtConfig.audience,  };  const token = jwt.sign(payload, jwtConfig.secret, {    expiresIn: jwtConfig.expiresIn,    algorithm: jwtConfig.algorithm,  });  return token;};export const verifyToken = (token: string): JwtPayload => {  try {    const payload = jwt.verify(token, jwtConfig.secret, {      algorithms: [jwtConfig.algorithm],      issuer: jwtConfig.issuer,      audience: jwtConfig.audience,    }) as JwtPayload;    return payload;  } catch (error) {    if (error instanceof jwt.TokenExpiredError) {      throw new Error('Token å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');    } else if (error instanceof jwt.JsonWebTokenError) {      throw new Error('Token æ— æ•ˆ');    } else {      throw new Error('Token éªŒè¯å¤±è´¥');    }  }};export const refreshToken = (oldToken: string): string => {  try {    const payload = jwt.verify(oldToken, jwtConfig.secret, {      ignoreExpiration: true,     }) as JwtPayload;    return generateToken(payload.userId);  } catch (error) {    throw new Error('Token åˆ·æ–°å¤±è´¥');  }};
